#include <windows.h>
#include <gl/GL.h>
#include <gl/GLU.h>
#include <gl/freeglut.h>
#include <iostream>
#include <vector>
#include <time.h>
#include <float.h>
#include <cmath>
#include "particle.h"
#include "forceParticle.h"

#define PI 3.14159265
using std::cout;
using std::vector;

int width = 800;
int height = 500;

const float ROOT_2_OVER_2 = sqrt(2) / 2;
const float ROOT_3_OVER_2 = sqrt(3) / 2;
const int INITIAL_PARTICLES = 200;

vector<Particle2D> particles;
vector<ForceParticle2D> forceParticles;
bool simulating = true;
float gRange = 0.0;
float mouseForceFactor = 0.1;
int forceParticleSize = 20;
float forceParticleDensity = 30.0;
bool attracting = false;
bool repulsing = false;
bool showRange = false;
bool showDirection = false;
bool particleFriction = true;
bool particleCollisionEnergyLoss = true;
int mouseX;
int mouseY;

/* ============== HELPERS ============== */
// 2 functions to remove closest particle for particles and forceParticles vectors
void removeClosestParticle(int x, int y)
{
    if (particles.size() == 0)
    {
        return;
    }

    float iMin = -1;
    float distMin = 0.0;
    for (long long unsigned i = 0; i < particles.size(); i++)
    {
        float dist = particles.at(i).pos.distanceTo(Point2D(x, y));
        if (iMin == -1)
        {
            iMin = i;
            distMin = dist;
        }
        else
        {
            if (dist < distMin)
            {
                distMin = dist;
                iMin = i;
            }
        }
    }
    particles.erase(particles.begin() + iMin);
}

void removeClosestForceParticle(int x, int y)
{
    if (forceParticles.size() == 0)
    {
        return;
    }

    float iMin = -1;
    float distMin = 0.0;
    for (long long unsigned i = 0; i < forceParticles.size(); i++)
    {
        float dist = forceParticles.at(i).pos.distanceTo(Point2D(x, y));
        if (iMin == -1)
        {
            iMin = i;
            distMin = dist;
        }
        else
        {
            if (dist < distMin)
            {
                distMin = dist;
                iMin = i;
            }
        }
    }
    forceParticles.erase(forceParticles.begin() + iMin);
}

// 2 functions to add particles to particles and forceParticles vectors
void addParticle(Particle2D p)
{
    particles.push_back(p);
}

void addForceParticle(ForceParticle2D fp)
{
    forceParticles.push_back(fp);
}

// function used to apply mouse force to particles in range
void attractParticlesTo(int x, int y, bool isRepulsing)
{
    Point2D mousePos = Point2D(x, y);
    for (long long unsigned i = 0; i < particles.size(); i++)
    {
        float range = particles.at(i).range + gRange;
        if (particles.at(i).pos.distanceTo(mousePos) <= range)
        {
            particles.at(i).mouseForce = Vec2D::createVector(particles.at(i).pos, mousePos).multiply((isRepulsing ? -1 : 1) * mouseForceFactor);
        }
    }
}

// update all particles
void updateParticles()
{
    for (long long unsigned i = 0; i < forceParticles.size(); i++)
    {
        for (long long unsigned j = 0; j < particles.size(); j++)
        {
            forceParticles.at(i).applyForceTo(&(particles.at(j)));
        }
    }

    for (long long unsigned i = 0; i < particles.size(); i++)
    {
        particles.at(i).hasFriction = particleFriction;
        particles.at(i).collisionEnergyLoss = particleCollisionEnergyLoss;
        particles.at(i).update(width, height);
    }
}

// functions for increasing and decreasing global variables
void increaseRange()
{
    if (gRange < 100)
    {
        gRange += 2;
    }
}

void decreaseRange()
{
    if (gRange > 0)
    {
        gRange -= 2;
    }
}

void increaseSpeed()
{
    if (mouseForceFactor < 1.0)
    {
        mouseForceFactor += 0.01;
    }
}

void decreaseSpeed()
{
    if (mouseForceFactor > 0.1)
    {
        mouseForceFactor -= 0.01;
    }
}

void increaseForceParticleSize()
{
    if (forceParticleSize < 100)
    {
        forceParticleSize += 2;
    }
}

void decreaseForceParticleSize()
{
    if (forceParticleSize > 10)
    {
        forceParticleSize -= 2;
    }
}

void increaseForceParticleDensity()
{
    if (forceParticleDensity < 1000.0)
    {
        forceParticleDensity += 10;
    }
}

void decreaseForceParticleDensity()
{
    if (forceParticleDensity > 10.0)
    {
        forceParticleDensity -= 10;
    }
}

/* ============== RANDOM ============== */
int random(int min, int max)
{
    rand(); // call initial rand() to add more randomness to function
    return (rand() % (max - min)) + min;
}

// used to initally randomized sequence generated by rand()
void randomizeSequence()
{
    srand(time(NULL));
    for (int i = 0; i < 50; i++)
    {
        rand();
    }
}

Particle2D generateRandomParticle(int x, int y)
{
    return Particle2D(
        Point2D(x, y),                                           //position
        Colour3(random(0, 256), random(0, 256), random(0, 256)), //colour
        random(7, 20),                                           //size
        Vec2D(0, 0),                                             //direction
        random(40, 80),                                          //range
        0,                                                       //speed
        particleFriction,
        particleCollisionEnergyLoss);
}

// overloaded function for random position for particle
Particle2D generateRandomParticle()
{
    return generateRandomParticle(random(20, width - 20), random(20, height - 20));
}

// used when pressing button to randomize all particle velocities
void randomizeParticleVelocities()
{
    for (long long unsigned int i = 0; i < particles.size(); i++)
    {
        particles.at(i).dir = Vec2D(random(-100, 100), random(-100, 100)).normalize();
        particles.at(i).speed = 1.0;
    }
}

void initialParticles(int num)
{
    for (int i = 0; i < num; i++)
    {
        addParticle(generateRandomParticle());
    }
}

/* ============== DRAW ============== */
// Function to generate points for a regular polygon with specific amount of sides.
// When # of sides are large, it looks like a circle
void regularPoly(int sides, Point2D pos, float radius)
{
    float degree = 360.0 / sides;

    for (int i = 0; i < sides; i++)
    {
        float rad = (degree * i * PI) / 180;
        float x = radius * cos(rad);
        float y = radius * sin(rad);
        glVertex2f(x + pos.mX, y + pos.mY);
    }
}

// used to draw particle and mouse ranges
void drawRange(Point2D pos, float radius, Colour3 col)
{
    glLineWidth(1);
    glBegin(GL_TRIANGLE_FAN);
    glColor4f(col.r, col.g, col.b, 0.1);
    regularPoly(32, pos, radius);
    glEnd();

    glBegin(GL_LINE_LOOP);
    glColor4f(col.r, col.g, col.b, 0.3);
    regularPoly(32, pos, radius);
    glEnd();
}

// used to draw direction of particle
void drawDirection(Particle2D p)
{
    Point2D end = p.getVelocity().normalize().multiply(20).movePoint(p.pos);
    glLineWidth(1);
    glBegin(GL_LINES);
    glColor3f(1, 0, 0);
    glVertex2f(p.pos.mX, p.pos.mY);
    glVertex2f(end.mX, end.mY);
    glEnd();
}

void drawParticle(Particle2D p)
{
    if (showRange)
    {
        drawRange(p.pos, p.range, Colour3(255, 255, 255));
    }
    glBegin(GL_TRIANGLE_FAN);
    glColor3f(p.col.r, p.col.g, p.col.b);
    regularPoly(32, p.pos, p.size / 2.0);
    glEnd();
    if (showDirection)
    {
        drawDirection(p);
    }
}

void drawParticles()
{
    for (long long unsigned i = 0; i < particles.size(); i++)
    {
        drawParticle(particles.at(i));
    }
}

void drawForceParticle(ForceParticle2D fp)
{
    glBegin(GL_TRIANGLE_FAN);
    if (!fp.repulsing)
    {
        glColor3f(2.0 / 255, 10.0 / 255, 56.0 / 255);
    }
    else
    {
        glColor3f(39.0 / 255, 3.0 / 255, 3.0 / 255);
    }
    regularPoly(32, fp.pos, fp.size / 2.0);
    glEnd();

    glLineWidth(3);
    glBegin(GL_LINE_LOOP);
    if (!fp.repulsing)
    {
        glColor3f(27.0 / 255, 4.0 / 255, 81.0 / 255);
    }
    else
    {
        glColor3f(51.0 / 255, 1.0 / 255, 1.0 / 255);
    }
    regularPoly(32, fp.pos, fp.size / 2.0);
    glEnd();
}

void drawForceParticles()
{
    for (long long unsigned i = 0; i < forceParticles.size(); i++)
    {
        drawForceParticle(forceParticles.at(i));
    }
}

// timer function that calculates and draws next frame
void drawFrame(int value)
{
    if (simulating)
    {
        updateParticles();
    }
    glutPostRedisplay();
    glutTimerFunc(17, drawFrame, 0);
}

// print inital program keybindings
void printProgramDetails()
{
    cout << "__________ Particles Program __________\n";
    cout << "LEFT MOUSE: Apply attracting force to partrices in range\n";
    cout << "RIGHT MOUSE: Apply repulsing force to partrices in range\n";
    cout << "Q/ESC: Quit program\n";
    cout << "A: Add particle at mouse position\n";
    cout << "D: Delete particle nearest to mouse position\n";
    cout << "S: Add attracting force particle at mouse position with current size and density\n";
    cout << "W: Add repulsing force particle at mouse position with current size and density\n";
    cout << "V: Delete force particle nearest to mouse position\n";
    cout << ".: Increase force particle size\n";
    cout << ",: Decrease force particle size\n";
    cout << ">: Increase force particle density\n";
    cout << "<: Decrease force particle density\n";
    cout << "UP: Increase mouse force\n";
    cout << "DOWN: Decrease mouse force\n";
    cout << "+: Increase mouse range\n";
    cout << "-: Decrease mouse range\n";
    cout << "X: Show particle and mouse range\n";
    cout << "R: Reset\n";
    cout << "Z: Randomize all particles' velocities\n";
    cout << "SPACE: Pause simulation\n";
    cout << "C: Show particle directions\n";
    cout << "E: Toggle particle energy loss on collision\n";
    cout << "F: Toggle particle friction\n";
    cout << "_______________________________________\n";
    cout << "Current Values: (P = Particle, FP = Force Particle)\n";
}

// used to print current values of specific global variables that dont have easy visual indicators
void printCurrentValues()
{
    cout << "\r";
    cout << "P Friction: " << (particleFriction ? "ON" : "OFF") << ", ";
    cout << " P Energy Loss: " << (particleCollisionEnergyLoss ? "ON" : "OFF") << ", ";
    cout << " Mouse Force: " << mouseForceFactor << ", ";
    cout << " FP Size: " << forceParticleSize << ", ";
    cout << " FP Density: " << forceParticleDensity << ", ";
    cout << " FP Mass: " << forceParticleSize * forceParticleDensity;
}

/* ============== EVENT HANDLERS ============== */
void idle()
{
    printCurrentValues();
    if (attracting)
    {
        attractParticlesTo(mouseX, mouseY, false);
    }
    else if (repulsing)
    {
        attractParticlesTo(mouseX, mouseY, true);
    }
}

void specialKeyboard(int key, int x, int y)
{
    switch (key)
    {
    case GLUT_KEY_UP:
        increaseSpeed();
        break;
    case GLUT_KEY_DOWN:
        decreaseSpeed();
        break;
    }
}

void keyboard(unsigned char key, int x, int y)
{
    y = height - y;
    switch (key)
    {
    case 'q':
    case 'Q':
    case 27: //ESC key
        exit(0);
        break;
    case 'a':
    case 'A':
        addParticle(generateRandomParticle(x, y));
        break;
    case 'd':
    case 'D':
        removeClosestParticle(x, y);
        break;
    case 's':
    case 'S':
        addForceParticle(ForceParticle2D(Point2D(x, y), forceParticleSize, Vec2D(0, 0), random(40, 80), 0, forceParticleDensity, false, particleFriction, particleCollisionEnergyLoss));
        break;
    case 'w':
    case 'W':
        addForceParticle(ForceParticle2D(Point2D(x, y), forceParticleSize, Vec2D(0, 0), random(40, 80), 0, forceParticleDensity, true, particleFriction, particleCollisionEnergyLoss));
        break;
    case 'v':
    case 'V':
        removeClosestForceParticle(x, y);
        break;
    case 'r':
    case 'R':
        particles.clear();
        initialParticles(INITIAL_PARTICLES);
        break;
    case '-':
    case '_':
        decreaseRange();
        break;
    case '=':
    case '+':
        increaseRange();
        break;
    case ',':
        decreaseForceParticleSize();
        break;
    case '.':
        increaseForceParticleSize();
        break;
    case '<':
        decreaseForceParticleDensity();
        break;
    case '>':
        increaseForceParticleDensity();
        break;
    case 'z':
    case 'Z':
        randomizeParticleVelocities();
        break;
    case ' ':
        simulating = !simulating;
        break;
    case 'x':
    case 'X':
        showRange = !showRange;
        break;
    case 'c':
    case 'C':
        showDirection = !showDirection;
        break;
    case 'e':
    case 'E':
        particleCollisionEnergyLoss = !particleCollisionEnergyLoss;
        break;
    case 'f':
    case 'F':
        particleFriction = !particleFriction;
        break;
    }
}

void mousePassiveDrag(int x, int y)
{
    y = height - y;
    mouseX = x;
    mouseY = y;
}

void mouseDrag(int x, int y)
{
    y = height - y;
    mouseX = x;
    mouseY = y;
    if (attracting)
    {
        attractParticlesTo(x, y, false);
    }
    else if (repulsing)
    {
        attractParticlesTo(x, y, true);
    }
}

void mouse(int button, int state, int x, int y)
{
    y = height - y;
    mouseX = x;
    mouseY = y;

    if (state == GLUT_UP)
    {
        if (button == GLUT_LEFT_BUTTON)
        {
            attracting = false;
        }
        else if (button == GLUT_RIGHT_BUTTON)
        {
            repulsing = false;
        }
        return;
    }

    if (button == GLUT_LEFT_BUTTON)
    {
        attracting = true;
        attractParticlesTo(x, y, false);
    }
    else if (button == GLUT_RIGHT_BUTTON)
    {
        repulsing = true;
        attractParticlesTo(x, y, true);
    }
}

void reshape(int w, int h)
{
    width = w;
    height = h;
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, width, 0, height);
    glMatrixMode(GL_MODELVIEW);
    glViewport(0, 0, width, height);
}

void display()
{
    glClear(GL_COLOR_BUFFER_BIT);
    drawForceParticles();
    drawParticles();
    if (showRange)
    {
        drawRange(Point2D(mouseX, mouseY), gRange, Colour3(255, 0, 0));
    }
    glutSwapBuffers();
}

/* ============== INIT/MAIN ============== */

void initializeGlut()
{
    glutInitWindowSize(width, height);
    glutInitWindowPosition(50, 50);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE);
    glutCreateWindow("Particle System");
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutSpecialFunc(specialKeyboard);
    glutMouseFunc(mouse);
    glutMotionFunc(mouseDrag);
    glutPassiveMotionFunc(mousePassiveDrag);
    glutIdleFunc(idle);
    glutTimerFunc(17, drawFrame, 0);
}

void init()
{
    initializeGlut();
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_BLEND);
    randomizeSequence();
    initialParticles(INITIAL_PARTICLES);
    printProgramDetails();
}

int main(int argc, char *argv[])
{
    glutInit(&argc, argv);
    init();
    glutMainLoop();
    return 0;
}
